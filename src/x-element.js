import XTemplate from "./x-template.js";
import logger from "./logger.js";


// utils
function kebabToCamel(str) {
    return str.split('-')
        .map((word, index) => index === 0 ? word : word.charAt(0).toUpperCase() + word.slice(1))
        .join('');
};
function camelToKebab(str) {
    return str
      .replace(/([a-z])([A-Z])/g, '$1-$2') 
      .toLowerCase();                      
}


// class
class XElement extends HTMLElement {


    //fields
    _instance = null;
    _state = null;
    _settings = {
        shadowRootOptions: { mode: "open"},
        backPropagatedAttributes: [],
        autoGeneratedProperties: true,
        dependencies: []
    };

    //work fields
    _connected = false;
    _loaded = false;
    _loadCalled = false;
    _renderTimeoutId = 0;
    
    //ctor
    constructor() {
        super();
        //definition
        let definition = this.constructor.definition || {};
        //settings        
        this._settings = (definition.settings ? Object.assign(this._settings, definition.settings) : this._settings);
        //shadowRoot
        let shadowRoot = this.attachShadow(this._settings.shadowRootOptions);
        //xtemplate
        if (!this.constructor.xtemplate) {
            let style = definition.style || [];
            let template = definition.template || "";
            this.constructor.xtemplate = new XTemplate({ 
                template, 
                styleSheets: style
            });
            this._settings.dependencies = this.constructor.xtemplate.dependencies;
        }
        //state
        let self = this;
        let rawState = definition.state && definition.state() || {};
        this._state = new Proxy(rawState, {
            set(target, prop, newValue) {
                let oldValue = target[prop];
                target[prop] = newValue;
                self.stateChanged(prop, oldValue, newValue);
                self.invalidate();
                return true;
            }
        });
        //instance
        this._instance = this.constructor.xtemplate.createInstance(
            rawState,
            (command, event) => {
                var handler = self[command];
                handler.call(self, event);
            }, 
            shadowRoot
        );
        //properties
        if (this._settings.autoGeneratedProperties && !this.constructor._autoGeneratedProperties) {
            this.constructor._autoGeneratedProperties = true;
            var propNames = [];
            if (Array.isArray(this._settings.autoGeneratedProperties)) {
                for(let propName of this._settings.autoGeneratedProperties) {
                    propNames.push(propName);
                }
            } else {
                for(let propName in rawState) {
                    propNames.push(propName);
                }
            }
            for(let propName of propNames) {
                Object.defineProperty(this.constructor.prototype, propName, {
                    get() {
                        return this.state[propName];
                    },
                    set(value) {
                        this.state[propName] = value;
                    }
                });
            }
        }
    }

    //props
    get settings() { return this._settings; }
    get state() { return this._state; }

    //events
    attributeChangedCallback(name, oldValue, newValue) {
        let prop = kebabToCamel(name);
        let oldPropValue = this._state[prop];
        if (typeof(oldPropValue) == "boolean") {
            newValue = (newValue != null);
        }
        if (oldPropValue != newValue) {
            this._state[prop] = newValue;
        }
    }
    connectedCallback() {
        this._connected = true;
        if (!this._loadCalled) {
            this._loaded = true;
            this.onLoad();
        }
        this.render();
    }
    disconnectedCallback() {
        this._connected= false;
        this.onUnload();
    }


    //methods to override
    onLoad() { 
        //to override
    }
    onStateChanged(name, oldValue, newValue) {
        //to override
    }
    onUnload() {
        //to override
    }

    //methods to not override
    stateChanged(prop, oldValue, newValue) {
        //a state prop changed
        let attr = camelToKebab(prop);
        if (this._settings.backPropagatedAttributes.indexOf(attr) != -1) {
            if (typeof(newValue) == "boolean") {
                if (newValue) {
                    if (!this.hasAttribute(attr)) this.setAttribute(attr, "");
                } else {
                    if (this.hasAttribute(attr)) this.removeAttribute(attr);
                }
            } else {
                let attrOldValue = this.getAttribute(attr);
                let attrNewValue = newValue ? newValue.toString() : "";
                    if (attrOldValue != attrNewValue) {
                    this.setAttribute(attr, attrNewValue);
                }
            }
        }
        this.onStateChanged(prop, oldValue, newValue);
    }    
    invalidate() {
        //enqueue a render
        if (this._connected) {
            if (!this._renderTimeoutId) {
                this._renderTimeoutId = window.requestAnimationFrame(() => {
                    this.render();
                });
            }
        }
    }
    render() {
        //count
        //const start = performance.now();
        //cancel pending render
        if (this._renderTimeoutId) {
            window.cancelAnimationFrame(this._renderTimeoutId);
            this._renderTimeoutId = 0;
        };
        //render
        this._instance.render();
        //log
        //const end = performance.now();
        //logger.log(`Rendered ${this.localName}, in ${end-start} ms`);
    }

}

//export
export default XElement;
